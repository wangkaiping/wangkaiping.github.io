{"meta":{"title":"Jedi's Blog","subtitle":"一天进步一点","description":"专注 Java 开发的技术博客","author":"程序猿Jedi","url":"http://wangkaiping.github.io"},"pages":[{"title":"about","date":"2017-11-04T04:10:47.000Z","updated":"2017-11-04T07:38:32.826Z","comments":true,"path":"about/index.html","permalink":"http://wangkaiping.github.io/about/index.html","excerpt":"","text":"关于我从事 WEB 开发，主要开发语言 Java。 对服务端、前端、数据分析等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：成都 关于学习正在往终身学习者前进…近期学习方向：Java 关于座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好热爱运动，尤其喜爱羽毛球、阅读、电影（Top250）、旅行。 联系我 Blog: blog.mlyai.com Email: wangkaiping_1990@sina.com Wechat: gy_wangkaiping QQ: 1015010708 Tel: 18408260927 GitHub: wangkaiping WeiBo: 程序猿Jedi"}],"posts":[{"title":"mybatis踩过的坑","slug":"mybatis踩过的坑","date":"2017-12-20T09:17:28.000Z","updated":"2018-01-02T09:01:45.887Z","comments":true,"path":"2017/12/20/mybatis踩过的坑/","link":"","permalink":"http://wangkaiping.github.io/2017/12/20/mybatis踩过的坑/","excerpt":"","text":"1、tinyint类型取值在数据库存储数据时，为了使数据在储存中占用更少的空间，也为了优化查询速度，我们可能在某些字段上需要设置它的类型为tinyint， 例如：某商品的状态储存、某用户的注册证件类型等等。 使用tinyint类型在判断或者存入数据到DB的时候没有问题，但是在读取数据的到实体类的时候 如果数据库里表中字段类型为tinyint，值是1，则使用mybatis查出来会显示为true；如果tinyint值是0，则mybatis查出来显示为false 解决办法： sql查询时进行数据类型转换。例如：select cast(status as signed) from test; 在相应的列上 1。例如：select status 1 as signed from test; 2、if test判断在项目中，我们经常会根据不同的条件筛选得到我们需要的结果列表，使用mybatis，常使用&lt;where&gt;&lt;if test=&quot;&quot;&gt;&lt;/if&gt;&lt;/where&gt; 这样的判断语句查询，然而在开发过程中偶遇到判断条件怎么检查都是正确的，然而程序执行时始终不进入相应的语句，比如下面这条语句： &lt;if test=&quot;takeWay == &apos;1&apos; and workday != null &quot;&gt; WORKDAY, &lt;/if&gt; takeWay == ‘1’ 处出错，导致不执行if判断中的sql，运行程序不报错，没有任何提示。去掉takeWay == ‘1’ and 则可执行。 &gt;&gt;&gt; 错误原因：mybatis是用OGNL表达式来解析的，在OGNL的表达式中，’1’会被解析成字符，java是强类型的，char 和 一个string 会导致不等， &gt;&gt;&gt; 所以if标签中的sql不会被解析。 解决办法：把&lt;if test=&quot;takeWay == &#39;1&#39; and workday != null &quot;&gt;改为&lt;if test=&#39;takeWay == &quot;1&quot; and workday != null &#39;&gt;或改为&lt;if test=&quot;takeWay == &#39;1&#39;.toString() and workday != null &quot;&gt;即可 3、Mybatis单个参数的if判断（针对异常：There is no getter for property..）在项目中，我们经常会根据主键或者某个特定的条件筛选得到我们需要的结果列表，使用mybatis，常使用&lt;where&gt;&lt;if test=&quot;&quot;&gt;&lt;/if&gt;&lt;/where&gt; 这样的判断语句查询，比如下面这条常规语句： &lt;select id=&quot;queryBannerList&quot; parameterType=&quot;com.rsr.mall.admin.po.AdminBannerPo&quot; resultType=&quot;com.rsr.mall.admin.domain.Banner&quot;&gt; select * from rsr_mall_banner mb &lt;where&gt; &lt;if test=&quot;queryTermCode!=null and queryTermCode!=&apos;&apos;&quot;&gt; and mb.term_code = #{queryTermCode} &lt;/if&gt; &lt;if test=&quot;status &gt; 0&quot;&gt; and mb.status = #{status} &lt;/if&gt; &lt;/where&gt; order by record_id &lt;/select&gt; 但是单个参数和多参数的判断有个不同点，当我们的入参为entity实体，或者map的时候，使用if 参数判断没任何问题。 但是当我们的入参为java.lang.Integer 或者 java.lang.String的时候，如下： &lt;select id=&quot;queryTermByCode&quot; parameterType=&quot;int&quot; resultType=&quot;com.rsr.mall.admin.dto.AppTerm&quot;&gt; SELECT code AS termCode, app_name AS termName FROM cp_app_terminal &lt;where&gt; &lt;if test=&quot;code != null and code &gt; 0&quot;&gt; AND code = #{code} &lt;/if&gt; AND `status` = 1 &lt;/where&gt; GROUP BY company_code &lt;/select&gt; 系统总是会抛出： Internal error : nested exception is org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;code&apos; in &apos;class java.lang.Integer&apos; 错误原因：参照http://blog.csdn.net/luanlouis/article/details/40422941。 解决办法：把&lt;if test=&quot;code != null and code &gt; 0&quot;&gt;改为&lt;if test=&quot;_parameter != null and _parameter &gt; 0&quot;&gt;即可，且最好追加jdbcType，指定映射类型","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://wangkaiping.github.io/categories/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://wangkaiping.github.io/tags/mybatis/"}]},{"title":"Spring-Cloud学习之路-问题记录","slug":"Spring-Cloud学习之路-问题记录","date":"2017-08-30T03:05:18.000Z","updated":"2017-11-04T07:24:47.355Z","comments":true,"path":"2017/08/30/Spring-Cloud学习之路-问题记录/","link":"","permalink":"http://wangkaiping.github.io/2017/08/30/Spring-Cloud学习之路-问题记录/","excerpt":"","text":"一：关于 hystrix 的异常 fallback method wasn’t found 错误日志如下：12342017-08-11 16:27:55.415 ERROR 8828 --- [nio-8030-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is com.netflix.hystrix.contrib.javanica.exception.FallbackDefinitionException: fallback method wasn&apos;t found: helloFallback([class java.lang.String])] with root causecom.netflix.hystrix.contrib.javanica.exception.FallbackDefinitionException: fallback method wasn&apos;t found: helloFallback([class java.lang.String]) ...... // 其余省略 出现如上所述的异常，这是因为指定的 备用方法 和 原方法 的参数个数，类型不同造成的； 如下代码： 12345678@HystrixCommand(fallbackMethod = &quot;helloFallback&quot;) public String helloService(String name) &#123; return restTemplate.getForEntity(&quot;http://hello-service/hello/&#123;name&#125;&quot;, String.class, name).getBody(); &#125; public String helloFallback()&#123; return &quot;can&apos;t get hello method, this name is &quot; ; &#125; 在这里原方法是带有参数，而备用方法则无参，修改为以下代码就可以解决问题： 12345678@HystrixCommand(fallbackMethod = &quot;helloFallback&quot;) public String helloService(String name) &#123; return restTemplate.getForEntity(&quot;http://hello-service/hello/&#123;name&#125;&quot;, String.class, name).getBody(); &#125; public String helloFallback(String name)&#123; return &quot;can&apos;t get hello method, this name is &quot; + name; &#125;","categories":[{"name":"Spring-Cloud","slug":"Spring-Cloud","permalink":"http://wangkaiping.github.io/categories/Spring-Cloud/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://wangkaiping.github.io/tags/Spring/"}]},{"title":"Spring-Cloud学习之路-Eureka服务注册","slug":"Spring-Cloud学习之路-Eureka服务注册","date":"2017-08-07T09:17:28.000Z","updated":"2017-11-04T07:21:58.447Z","comments":true,"path":"2017/08/07/Spring-Cloud学习之路-Eureka服务注册/","link":"","permalink":"http://wangkaiping.github.io/2017/08/07/Spring-Cloud学习之路-Eureka服务注册/","excerpt":"","text":"本博客是基于Dalston.SR2版本编写，理解有不对的地方希望读者指出，留言评论，一起学习了解。 参考文章：【Spring Cloud源码分析（一）Eureka 】及【深入理解Eureka之源码解析】 我们将一个普通的Spring-Boot应用注册到Eureka Servcer或者从Eureka Server中获取服务列表时，主要做了以下两件事： 在应用主类中配置了@EnableDiscoveryClient 在application.properties中用eureka.client.service-url.defaultZone参数指定了服务注册中心的位置 首先我们来看看@EnableDiscoveryClient的源码： 12345678910111213141516/** * Annotation to enable a DiscoveryClient implementation. * @author Spencer Gibb */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(EnableDiscoveryClientImportSelector.class)public @interface EnableDiscoveryClient &#123; /** * If true, the ServiceRegistry will automatically register the local server. */ boolean autoRegister() default true;&#125; 注释解释：@Target:指定程序元定义的注释所使用的地方，它使用了另一个类：ElementType，是一个枚举类定义了注释类型可以应用到不同的程序元素以免使用者误用ElementType是一个枚举类型，指明注释可以使用的地方，看看ElementType类： 12345678910public enum ElementType &#123; TYPE, // 指定适用点为 class, interface, enum FIELD, // 指定适用点为 field METHOD, // 指定适用点为 method PARAMETER, // 指定适用点为 method 的 parameter CONSTRUCTOR, // 指定适用点为 constructor LOCAL_VARIABLE, // 指定使用点为 局部变量 ANNOTATION_TYPE, //指定适用点为 annotation 类型 PACKAGE // 指定适用点为 package &#125; @Retention：这个元注释和java编译器处理注释的注释类型方式相关，告诉编译器在处理自定义注释类型的几种不同的选择，需要使用RetentionPolicy枚举类枚举类只有一个成员变量，可以不用指明成名名称而赋值，看Retention的源代码： 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; RetentionPolicy value();&#125; 类中有个RetentionPolicy类，也是一个枚举类，具体看代码： 12345public enum RetentionPolicy &#123; SOURCE, // 编译器处理完Annotation后不存储在class中 CLASS, // 编译器把Annotation存储在class中，这是默认值 RUNTIME // 编译器把Annotation存储在class中，可以由虚拟机读取,反射需要 &#125; @Documented：是一个标记注释，表示注释应该出现在类的javadoc中，因为在默认情况下注释时不包括在javadoc中的。注意他与@Retention(RetentionPolicy.RUNTIME)配合使用，因为只有将注释保留在编译后的类文件中由虚拟机加载， 然后javadoc才能将其抽取出来添加至javadoc中。 @Inherited：将注释同样继承至使用了该注释类型的方法中（表达有点问题，就是如果一个方法使用了的注释用了@inherited， 那么其子类的该方法同样继承了该注释） 由此EnableDiscoveryClient注释，我们可以看出，它主要用来开启DiscoveryClient的实例。我们搜索DiscoveryClient可以发现有一个类与一个接口。在com.netflix.discovery包下的DiscoveryClient类，该类包含了Eureka Client向Eureka Server的相关方法。其中DiscoveryClient实现了EurekaClient接口，并且它是一个单例模式，而EurekaClient继承了LookupService接口。它们之间的关系如图所示。 继续看源码，在DiscoveryClient类中，我们看到有一个register()，其源码如下： 123456789101112131415161718/** * Register with the eureka service by making the appropriate REST call. */boolean register() throws Throwable &#123; logger.info(PREFIX + appPathIdentifier + &quot;: registering service...&quot;); EurekaHttpResponse&lt;Void&gt; httpResponse; try &#123; // Eureka Client客户端，调用Eureka服务端的入口 httpResponse = eurekaTransport.registrationClient.register(instanceInfo); &#125; catch (Exception e) &#123; logger.warn(&quot;&#123;&#125; - registration failed &#123;&#125;&quot;, PREFIX + appPathIdentifier, e.getMessage(), e); throw e; &#125; if (logger.isInfoEnabled()) &#123; logger.info(&quot;&#123;&#125; - registration status: &#123;&#125;&quot;, PREFIX + appPathIdentifier, httpResponse.getStatusCode()); &#125; return httpResponse.getStatusCode() == 204;&#125; 我们找到了服务注册的代码，那么我们由此继续追踪它被调用的地方，追踪发现它被com.netflix.discovery.InstanceInfoReplicator 类的run()方法调用，其中InstanceInfoReplicator实现了Runnable接口，run()方法代码如下： 123456789101112131415public void run() &#123; try &#123; discoveryClient.refreshInstanceInfo(); Long dirtyTimestamp = instanceInfo.isDirtyWithTime(); if (dirtyTimestamp != null) &#123; discoveryClient.register(); instanceInfo.unsetIsDirty(dirtyTimestamp); &#125; &#125; catch (Throwable t) &#123; logger.warn(&quot;There was a problem with the instance info replicator&quot;, t); &#125; finally &#123; Future next = scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS); scheduledPeriodicRef.set(next); &#125; &#125; InstanceInfoReplicator类是在DiscoveryClient初始化过程中使用的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131@InjectDiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args, Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123; if (args != null) &#123; this.healthCheckHandlerProvider = args.healthCheckHandlerProvider; this.healthCheckCallbackProvider = args.healthCheckCallbackProvider; this.eventListeners.addAll(args.getEventListeners()); &#125; else &#123; this.healthCheckCallbackProvider = null; this.healthCheckHandlerProvider = null; &#125; this.applicationInfoManager = applicationInfoManager; InstanceInfo myInfo = applicationInfoManager.getInfo(); clientConfig = config; staticClientConfig = clientConfig; transportConfig = config.getTransportConfig(); instanceInfo = myInfo; if (myInfo != null) &#123; appPathIdentifier = instanceInfo.getAppName() + &quot;/&quot; + instanceInfo.getId(); &#125; else &#123; logger.warn(&quot;Setting instanceInfo to a passed in null value&quot;); &#125; this.backupRegistryProvider = backupRegistryProvider; this.urlRandomizer = new EndpointUtils.InstanceInfoBasedUrlRandomizer(instanceInfo); localRegionApps.set(new Applications()); fetchRegistryGeneration = new AtomicLong(0); remoteRegionsToFetch = new AtomicReference&lt;String&gt;(clientConfig.fetchRegistryForRemoteRegions()); remoteRegionsRef = new AtomicReference&lt;&gt;(remoteRegionsToFetch.get() == null ? null : remoteRegionsToFetch.get().split(&quot;,&quot;)); if (config.shouldFetchRegistry()) &#123; this.registryStalenessMonitor = new ThresholdLevelsMetric(this, METRIC_REGISTRY_PREFIX + &quot;lastUpdateSec_&quot;, new long[]&#123;15L, 30L, 60L, 120L, 240L, 480L&#125;); &#125; else &#123; this.registryStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC; &#125; if (config.shouldRegisterWithEureka()) &#123; this.heartbeatStalenessMonitor = new ThresholdLevelsMetric(this, METRIC_REGISTRATION_PREFIX + &quot;lastHeartbeatSec_&quot;, new long[]&#123;15L, 30L, 60L, 120L, 240L, 480L&#125;); &#125; else &#123; this.heartbeatStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC; &#125; logger.info(&quot;Initializing Eureka in region &#123;&#125;&quot;, clientConfig.getRegion()); if (!config.shouldRegisterWithEureka() &amp;&amp; !config.shouldFetchRegistry()) &#123; logger.info(&quot;Client configured to neither register nor query for data.&quot;); scheduler = null; heartbeatExecutor = null; cacheRefreshExecutor = null; eurekaTransport = null; instanceRegionChecker = new InstanceRegionChecker(new PropertyBasedAzToRegionMapper(config), clientConfig.getRegion()); // This is a bit of hack to allow for existing code using DiscoveryManager.getInstance() // to work with DI&apos;d DiscoveryClient DiscoveryManager.getInstance().setDiscoveryClient(this); DiscoveryManager.getInstance().setEurekaClientConfig(config); initTimestampMs = System.currentTimeMillis(); logger.info(&quot;Discovery Client initialized at timestamp &#123;&#125; with initial instances count: &#123;&#125;&quot;, initTimestampMs, this.getApplications().size()); return; // no need to setup up an network tasks and we are done &#125; try &#123; scheduler = Executors.newScheduledThreadPool(3, new ThreadFactoryBuilder() .setNameFormat(&quot;DiscoveryClient-%d&quot;) .setDaemon(true) .build()); heartbeatExecutor = new ThreadPoolExecutor( 1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), new ThreadFactoryBuilder() .setNameFormat(&quot;DiscoveryClient-HeartbeatExecutor-%d&quot;) .setDaemon(true) .build() ); // use direct handoff cacheRefreshExecutor = new ThreadPoolExecutor( 1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), new ThreadFactoryBuilder() .setNameFormat(&quot;DiscoveryClient-CacheRefreshExecutor-%d&quot;) .setDaemon(true) .build() ); // use direct handoff eurekaTransport = new EurekaTransport(); scheduleServerEndpointTask(eurekaTransport, args); AzToRegionMapper azToRegionMapper; if (clientConfig.shouldUseDnsForFetchingServiceUrls()) &#123; azToRegionMapper = new DNSBasedAzToRegionMapper(clientConfig); &#125; else &#123; azToRegionMapper = new PropertyBasedAzToRegionMapper(clientConfig); &#125; if (null != remoteRegionsToFetch.get()) &#123; azToRegionMapper.setRegionsToFetch(remoteRegionsToFetch.get().split(&quot;,&quot;)); &#125; instanceRegionChecker = new InstanceRegionChecker(azToRegionMapper, clientConfig.getRegion()); &#125; catch (Throwable e) &#123; throw new RuntimeException(&quot;Failed to initialize DiscoveryClient!&quot;, e); &#125; if (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(false)) &#123; fetchRegistryFromBackup(); &#125; // 启动的时候初始化的一个定时任务，把本地的服务配置信息，自动刷新到注册服务器上。 initScheduledTasks(); try &#123; Monitors.registerObject(this); &#125; catch (Throwable e) &#123; logger.warn(&quot;Cannot register timers&quot;, e); &#125; // This is a bit of hack to allow for existing code using DiscoveryManager.getInstance() // to work with DI&apos;d DiscoveryClient DiscoveryManager.getInstance().setDiscoveryClient(this); DiscoveryManager.getInstance().setEurekaClientConfig(config); initTimestampMs = System.currentTimeMillis(); logger.info(&quot;Discovery Client initialized at timestamp &#123;&#125; with initial instances count: &#123;&#125;&quot;, initTimestampMs, this.getApplications().size());&#125; 追踪源码initScheduledTasks(): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Initializes all scheduled tasks. */private void initScheduledTasks() &#123; if (clientConfig.shouldFetchRegistry()) &#123; // registry cache refresh timer int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds(); int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound(); // 服务获取 scheduler.schedule( new TimedSupervisorTask( &quot;cacheRefresh&quot;, scheduler, cacheRefreshExecutor, registryFetchIntervalSeconds, TimeUnit.SECONDS, expBackOffBound, new CacheRefreshThread() ), registryFetchIntervalSeconds, TimeUnit.SECONDS); &#125; if (clientConfig.shouldRegisterWithEureka()) &#123; int renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs(); int expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound(); logger.info(&quot;Starting heartbeat executor: &quot; + &quot;renew interval is: &quot; + renewalIntervalInSecs); // Heartbeat timer // 服务续约 scheduler.schedule( new TimedSupervisorTask( &quot;heartbeat&quot;, scheduler, heartbeatExecutor, renewalIntervalInSecs, TimeUnit.SECONDS, expBackOffBound, new HeartbeatThread() ), renewalIntervalInSecs, TimeUnit.SECONDS); // 服务注册 instanceInfoReplicator = new InstanceInfoReplicator( this, instanceInfo, clientConfig.getInstanceInfoReplicationIntervalSeconds(), 2); // burstSize statusChangeListener = new ApplicationInfoManager.StatusChangeListener() &#123; @Override public String getId() &#123; return &quot;statusChangeListener&quot;; &#125; @Override public void notify(StatusChangeEvent statusChangeEvent) &#123; if (InstanceStatus.DOWN == statusChangeEvent.getStatus() || InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123; // log at warn level if DOWN was involved logger.warn(&quot;Saw local status change event &#123;&#125;&quot;, statusChangeEvent); &#125; else &#123; logger.info(&quot;Saw local status change event &#123;&#125;&quot;, statusChangeEvent); &#125; instanceInfoReplicator.onDemandUpdate(); &#125; &#125;; if (clientConfig.shouldOnDemandUpdateStatusChange()) &#123; applicationInfoManager.registerStatusChangeListener(statusChangeListener); &#125; instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds()); &#125; else &#123; logger.info(&quot;Not registering with Eureka server per configuration&quot;); &#125;&#125; 该方法主要开启了获取服务注册列表的信息，如果需要向Eureka Server注册，则开启注册，同时开启了定时向Eureka Server服务续约的定时任务。在源码中我们可以发现，“服务获取”任务相对于“服务注册”和“服务续约”任务则更为独立。服务注册”和“服务续约”任务在同一个if语句中，这个是很容易理解的，服务注册到Eureka Server后，自然需要区续约，告诉Eureka Server它还活着，防止被剔除，所以他们会出现在一块儿。 “服务续约”： 12345678910111213141516171819/** * Renew with the eureka service by making the appropriate REST call */boolean renew() &#123; EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse; try &#123; httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null); logger.debug(&quot;&#123;&#125; - Heartbeat status: &#123;&#125;&quot;, PREFIX + appPathIdentifier, httpResponse.getStatusCode()); if (httpResponse.getStatusCode() == 404) &#123; REREGISTER_COUNTER.increment(); logger.info(&quot;&#123;&#125; - Re-registering apps/&#123;&#125;&quot;, PREFIX + appPathIdentifier, instanceInfo.getAppName()); return register(); &#125; return httpResponse.getStatusCode() == 200; &#125; catch (Throwable e) &#123; logger.error(&quot;&#123;&#125; - was unable to send heartbeat!&quot;, PREFIX + appPathIdentifier, e); return false; &#125;&#125; 继续查看源码，我们可以发现“服务续约”及“服务获取”都是以REST请求的方式实现的，就不多阐述了，有兴趣的朋友可以去看下源码。 服务注册中心处理 Eureka Servcer对于各类REST请求的定义都是位于com.netflix.eureka.resources包下 Eureka server服务端请求入口ApplicationResource.java文件中，如下所示，可以看出Eureka是通过http post的方式去服务注册 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Registers information about a particular instance for an * &#123;@link com.netflix.discovery.shared.Application&#125;. * * @param info * &#123;@link InstanceInfo&#125; information of the instance. * @param isReplication * a header parameter containing information whether this is * replicated from other nodes. */@POST@Consumes(&#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;)public Response addInstance(InstanceInfo info, @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) &#123; logger.debug(&quot;Registering instance &#123;&#125; (replication=&#123;&#125;)&quot;, info.getId(), isReplication); // validate that the instanceinfo contains all the necessary required fields if (isBlank(info.getId())) &#123; return Response.status(400).entity(&quot;Missing instanceId&quot;).build(); &#125; else if (isBlank(info.getHostName())) &#123; return Response.status(400).entity(&quot;Missing hostname&quot;).build(); &#125; else if (isBlank(info.getAppName())) &#123; return Response.status(400).entity(&quot;Missing appName&quot;).build(); &#125; else if (!appName.equals(info.getAppName())) &#123; return Response.status(400).entity(&quot;Mismatched appName, expecting &quot; + appName + &quot; but was &quot; + info.getAppName()).build(); &#125; else if (info.getDataCenterInfo() == null) &#123; return Response.status(400).entity(&quot;Missing dataCenterInfo&quot;).build(); &#125; else if (info.getDataCenterInfo().getName() == null) &#123; return Response.status(400).entity(&quot;Missing dataCenterInfo Name&quot;).build(); &#125; // handle cases where clients may be registering with bad DataCenterInfo with missing data DataCenterInfo dataCenterInfo = info.getDataCenterInfo(); if (dataCenterInfo instanceof UniqueIdentifier) &#123; String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId(); if (isBlank(dataCenterInfoId)) &#123; boolean experimental = &quot;true&quot;.equalsIgnoreCase(serverConfig.getExperimental(&quot;registration.validation.dataCenterInfoId&quot;)); if (experimental) &#123; String entity = &quot;DataCenterInfo of type &quot; + dataCenterInfo.getClass() + &quot; must contain a valid id&quot;; return Response.status(400).entity(entity).build(); &#125; else if (dataCenterInfo instanceof AmazonInfo) &#123; AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo; String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId); if (effectiveId == null) &#123; amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId()); &#125; &#125; else &#123; logger.warn(&quot;Registering DataCenterInfo of type &#123;&#125; without an appropriate id&quot;, dataCenterInfo.getClass()); &#125; &#125; &#125; registry.register(info, &quot;true&quot;.equals(isReplication)); return Response.status(204).build(); // 204 to be backwards compatible&#125; 在进行很多次校验以后，它会调用com.netflix.eureka.registry.PeerAwareInstanceRegistry的实现类com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl中的public void register(final InstanceInfo info, final boolean isReplication)来进行服务注册 123456789101112131415161718192021/** * Registers the information about the &#123;@link InstanceInfo&#125; and replicates * this information to all peer eureka nodes. If this is replication event * from other replica nodes then it is not replicated. * * @param info * the &#123;@link InstanceInfo&#125; to be registered and replicated. * @param isReplication * true if this is a replication event from other replica nodes, * false otherwise. */@Overridepublic void register(final InstanceInfo info, final boolean isReplication) &#123; // 默认的服务失效时间 int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS; if (info.getLeaseInfo() != null &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; 0) &#123; leaseDuration = info.getLeaseInfo().getDurationInSecs(); &#125; super.register(info, leaseDuration, isReplication); replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);&#125; 在此方法中，我们可以看到它加入了一个服务默认90秒的失效时间，若Eureka Client中没有“服务续约”，那么在90秒后Eureka Service会将此服务剔除，在这里我们可以看到，我们在自定义设置“服务续约”间隔时间时，应该设置为小于服务失效时间。 其中 super.register(info, leaseDuration, isReplication)方法，点击进去到子类AbstractInstanceRegistry可以发现更多细节，其中注册列表的信息被保存在一个Map中。replicateToPeers()方法，即同步到其他Eureka Server的其他Peers节点，它会遍历循环向所有的Peers注册，最终执行类com.netflix.eureka.cluster.PeerEurekaNode的register()方法，该方法通过执行一个任务向其他节点同步该注册信息: 123456789101112131415161718192021/** * Sends the registration information of &#123;@link InstanceInfo&#125; receiving by * this node to the peer node represented by this class. * * @param info * the instance information &#123;@link InstanceInfo&#125; of any instance * that is send to this instance. * @throws Exception */public void register(final InstanceInfo info) throws Exception &#123; long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info); batchingDispatcher.process( taskId(&quot;register&quot;, info), new InstanceReplicationTask(targetHost, Action.Register, info, null, true) &#123; public EurekaHttpResponse&lt;Void&gt; execute() &#123; return replicationClient.register(info); &#125; &#125;, expiryTime );&#125; 刚开始学习Spring-Cloud 如果有什么写的不对的地方，请提出指正。不喜勿喷，谢谢。","categories":[{"name":"Spring-Cloud","slug":"Spring-Cloud","permalink":"http://wangkaiping.github.io/categories/Spring-Cloud/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://wangkaiping.github.io/tags/Spring/"}]},{"title":"Spring-Cloud学习之路-简单的Eureka","slug":"Spring-Cloud学习之路-简单的Eureka","date":"2017-08-07T09:17:28.000Z","updated":"2017-11-04T07:23:53.038Z","comments":true,"path":"2017/08/07/Spring-Cloud学习之路-简单的Eureka/","link":"","permalink":"http://wangkaiping.github.io/2017/08/07/Spring-Cloud学习之路-简单的Eureka/","excerpt":"","text":"上一篇【Spring-Cloud学习之路-版本说明】中提到了spring-cloud的版本依赖。 这里开始创建一个简单的Demo，我使用的IDE是IntelliJ IDEA 2016.2.5 首先：File –&gt; New –&gt; Project 此处因为我电脑上安装的JDK是7.0的 所以我选择的java版本是1.7 spring-boot版本我选择的1.5.6 红框内值得我们关注，它不仅包含了Spring Boot Starter POMs中的各个依赖，还包含了Spring Cloud的各种依赖。 点击Next，进入最后关于工程物理存储的一些细节。最后，点击Finish就能完成工程的构建了。 创建完成后的项目结构如图： 图中.mvn文件夹/mvnw/mvnw.cmd 是我们不需要的，我直接是删除掉的。 然后创建Eureka-Service模块，方法同上，就不再累述； 创建完成后的整体项目结构： 引入想依赖的jar，完成后的pom.xml： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.jedi&lt;/groupId&gt; &lt;artifactId&gt;eureka-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-service&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;spring-cloud.version&gt;Dalston.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 在主应用类中添加 @EnableEurekaServer 注解 12345678@SpringBootApplication@EnableEurekaServerpublic class EurekaServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServiceApplication.class, args); &#125;&#125; 在application.properties中添加： 12345678910111213spring.application.name=eureka-server# eureka-service 端口server.port=8010eureka.instance.hostname=localhost#是否将本应用作为服务提供者注册到eurekaeureka.client.register-with-eureka=false#是否从eureka获取注册信息eureka.client.fetch-registry=false# eureka服务器的地址（注意：地址最后面的 /eureka/ 这个是固定值）eureka.client.serviceUrl.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/logging.file=$&#123;spring.application.name&#125;.log 至此一个简单的Eureka-service就完成了，然后我们访问 http://localhost:8010/ 可以看到如下界面： 创建Service Provider（服务提供者）同上创建两个个Module，分别取名：service-provider-1，service-provider-2 首先需要做的就是在pom中引入Spring Cloud Eureka的依赖。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 启用Service Provider非常简单，只需要加上@EnableDiscoveryClient即可。 12345678@SpringBootApplication@EnableDiscoveryClientpublic class ServiceProvider1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceProvider1Application.class, args); &#125;&#125; application.properties:（eureka-provider-2的配置同） 1234567spring.application.name=eureka-provider-1# 端口server.port=8020# eureka服务器的地址（注意：地址最后面的 /eureka/ 这个是固定值）eureka.client.serviceUrl.defaultZone=http://localhost:8010/eureka/logging.file=$&#123;spring.application.name&#125;.log","categories":[{"name":"Spring-Cloud","slug":"Spring-Cloud","permalink":"http://wangkaiping.github.io/categories/Spring-Cloud/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://wangkaiping.github.io/tags/Spring/"}]},{"title":"Spring-Cloud学习之路-版本说明","slug":"Spring-Cloud学习之路-版本说明","date":"2017-08-07T07:01:25.000Z","updated":"2017-11-04T07:22:18.788Z","comments":true,"path":"2017/08/07/Spring-Cloud学习之路-版本说明/","link":"","permalink":"http://wangkaiping.github.io/2017/08/07/Spring-Cloud学习之路-版本说明/","excerpt":"","text":"本博客参考内容: 翟永超大神的《SpringCloud微服务实战》一书 最近刚开始自主学习spring-cloud，在pom.xml中总是被眼花缭乱的版本号弄得自己不知所措，比如：Angel.SR6、Brixton.SR5、Dalston.SR1等等之类的。 由于Spring Cloud是一个拥有诸多子项目的大型综合项目，可以说是对微服务架构解决方案的综合套件组件，其中包含的各个子项目都独立的进行着内容的迭代与更新，各自维护自己的发布版本号。 因此每一个Spring Cloud的版本都包含了不同版本的子项目，为了管理每个版本的子项目清单，避免版本号与其子项目的版本号混淆，故没有采用版本号的方式，而是采用版本名的方式。 这些版本采用的伦敦地铁站的名字，按照字母排序对应版本的时间顺序比如最早的RELEASE版本是 Angel，第二是Birxton…… 那么不难理解 版本名后面的SR4、SR5就是版本号了（service Release 4） 当一个Spring cloud 项目的发布内容积累到临界点或者一个严重的BUG解决可用后，就会发布一个“service Release”版本， 简称SR（X）版本，x是一个递增数字 所以 Dalston.SR1就是 Dalston的第1个 service Release 版本 下图是spring-cloud官方给出的最新依赖的版本（Spring）： 下图是GitHub上spring-cloud版本更新记录（GitHub上spring-cloud版本更新记录）： 在官网上最后：1234567891011Finchley builds and works with Spring Boot 2.0.x, and is not expected to work with Spring Boot 1.5.x.-- Finchley构建并使用Spring Boot 2.0.x，并且不期望与Spring Boot 1.5.x一起使用。The Dalston and Edgware release trains build on Spring Boot 1.5.x, and are not expected to work with Spring Boot 2.0.x. -- Dalston和Edgware建立在Spring Boot 1.5.x上，并不期望与Spring Boot 2.0.x一起使用。The Camden release train builds on Spring Boot 1.4.x, but is also tested with 1.5.x. -- Camden搭载Spring Boot 1.4.x，但也经过1.5.x测试。The Brixton release train builds on Spring Boot 1.3.x, but is also tested with 1.4.x. -- Brixton搭载Spring Boot 1.3.x，但也经过1.4.x测试。The Angel release train builds on Spring Boot 1.2.x, and is incompatible in some areas with Spring Boot 1.3.x. Brixton builds on Spring Boot 1.3.x and is similarly incompatible with 1.2.x. Some libraries and most apps built on Angel will run fine on Brixton, but changes will be required anywhere that the OAuth2 features from spring-cloud-security 1.0.x are used (they were mostly moved to Spring Boot in 1.3.0).-- Angel版本建立在Spring Boot 1.2.x上，在某些领域与Spring Boot 1.3.x不兼容。Brixton构建在Spring Boot 1.3.x上，与1.2.x类似。某些libraries和大部分基于Angel的应用程序都将在Brixton上运行良好，但是在使用Spring-cloud-security 1.0.x的OAuth2功能之前，它们将会在任何地方进行更改。","categories":[{"name":"Spring-Cloud","slug":"Spring-Cloud","permalink":"http://wangkaiping.github.io/categories/Spring-Cloud/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://wangkaiping.github.io/tags/Spring/"}]},{"title":"使用plupload压缩图片","slug":"使用plupload压缩图片","date":"2017-06-29T06:49:38.000Z","updated":"2017-11-04T07:26:08.977Z","comments":true,"path":"2017/06/29/使用plupload压缩图片/","link":"","permalink":"http://wangkaiping.github.io/2017/06/29/使用plupload压缩图片/","excerpt":"","text":"Plupload 是一个Web浏览器上的界面友好的文件上传模块，可显示上传进度、图像自动缩略和上传分块。可同时上传多个文件。 Plupload有以下功能和特点： 1、拥有多种上传方式：HTML5、flash、silverlight以及传统的。Plupload会自动侦测当前的环境，选择最合适的上传方式，并且会优先使用HTML5的方式。所以你完全不用去操心当前的浏览器支持哪些上传方式，Plupload会自动为你选择最合适的方式。 2、支持以拖拽的方式来选取要上传的文件 3、支持在前端压缩图片，即在图片文件还未上传之前就对它进行压缩 4、可以直接读取原生的文件数据，这样的好处就是例如可以在图片文件还未上传之前就能把它显示在页面上预览 5、支持把大文件切割成小片进行上传，因为有些浏览器对很大的文件比如几G的一些文件无法上传。 我们在上传图片的时候，图片有大有小，图片过大上传至服务器端会占用大量的服务器内存，所以我们在前端上传图片时就会先对图片进行压缩处理，使用plupload上传，在实例化一个plupload对象时，传入配置参数resize： 123456789101112131415161718192021// 可以使用该参数对将要上传的图片进行压缩，该参数是一个对象，里面包括5个属性：// width：指定压缩后图片的宽度，如果没有设置该属性则默认为原始图片的宽度// height：指定压缩后图片的高度，如果没有设置该属性则默认为原始图片的高度// crop：是否裁剪图片// quality：压缩后图片的质量，只对jpg格式的图片有效，默认为90。quality可以跟width和height一起使用，但也可以单独使用，单独使用时，压缩后图片的宽高不会变化，但由于质量降低了，所以体积也会变小// preserve_headers：压缩后是否保留图片的元数据，true为保留，false为不保留,默认为true。删除图片的元数据能使图片的体积减小一点点// resize参数的配置示例如下：resize: &#123; width: 100, height: 100, crop: true, quality: 60, preserve_headers: false&#125; width与height的单位为像素（px），在实际使用过程中， 我们往往不能控制图片的宽高尺寸，而在resize参数配置中又不能使用%，否则会抛异常，为了符合我们要等比例缩放图片的效果，我在使用中只使用width、crop、preserve_headers参数，如下： 12345resize: &#123; width: 1000, crop: false, preserve_headers: true&#125; 这里宽度我使用的1000，意思就是如果图片宽小于1000，则不会改变原图片大小，只是删除元数据进行图片压缩，若图片宽度大于1000，则会等比例缩放图片进行压缩。 （第一次写博客，不喜勿喷，谢谢）","categories":[{"name":"前端","slug":"前端","permalink":"http://wangkaiping.github.io/categories/前端/"}],"tags":[{"name":"plupload","slug":"plupload","permalink":"http://wangkaiping.github.io/tags/plupload/"}]}]}